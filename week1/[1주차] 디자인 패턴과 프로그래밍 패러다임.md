# 1장 (16p ~66p)

[디자인 패턴(Design Pattern)](https://www.devkuma.com/docs/design-pattern/)

# 1.1 디자인 패턴

### 용어 정리

<aside>
💡 **— 라이브러리와 프레임 워크**                                                                                               모두 공통으로 사용될 수 있는 특정한 기능들을 모듈화 한것을 의미하나. 규칙이 없고 자유로운 라이브러리에 비해, 프레임워크는 폴더명, 파일명 등에 대한 ‘규칙’이 존재하며 비교적 엄격하다.                                                                                                              ex) 라이브러리 :: 가위(내가 직접 컨트롤) /                                                                        프레임워크 :: 비행기(비행기가 컨트롤 나는 이용만)                                                                                                                             **“제어 흐름의 주도권이 어디에 있는가”** 가 둘을 가르는 차이

</aside>

<aside>
📌 **— Enum**                                                                                                                                      상수의 집합을 정의할 때 사용되는 타입                                                                                        코드 리팩터링 시 상수 집합에 대한 **로직 수정이 쉬움**.                                                             **스레드 세이프** 하기 때문에 싱글톤 패턴을 만들 때 도움이 됨

</aside>

<aside>
📌 — DOM                                                                                                                                    Document Object Mode : 문서객체 모델을 말하며, 웹 브라우저상의 화면을 이루고 있는 요소들을 지칭

</aside>

## 디자인 패턴의 정의

> 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결 할 수 있도록 하나의 ‘규약’ 형태로 만들어 놓은 것.
> 

## 싱글톤 패턴 구현방법 (자바스크립트& 자바)

> 싱글톤 패턴 : 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴
> 
- 데이터 베이스 연결 모듈에 주로 사용
- 하나의 인스턴스를 만들어 놓고 모듈들이 이를 공유하며 사용한다
    
    장점 → 인스턴스 생성 비용이 줄어든다.
    
    단점 → 의존성이 높아진다.
    

```java
//차후 추가
//자바는 중첩클래스를 이용해서 실글톤을 구현한다.
```

### 싱글톤 단점

TDD(Test Driven Development) 시에 걸림돌이 된다.

⇒ 단위 테스트를 위해서는 의존성이 적어야 하지만, 싱글 톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다 ‘독립적인’ 인스턴스를 만들기는 어렵다.

### 의존성 주입

모듈 간의 결합을 강하게 만드는 부작용이 존재.

의존성 주입(DI, Dependency Injection)을 통해 모듈 간의 결합을 느슨하게 만들어 해결 가능하다.

메인 모듈이 ‘직접’ 하위 모듈에게 의존성을 주기보다, 중간에서 의존성 주입자가 이 부분을 가로채 메인 모듈이 ‘**간접’** 적으로 의존성을 주입하는 방식

⇒ 이를 통해 메인모듈(상위 모듈)은 하위 모듈에 대한 의존성이 떨어진다. == ’Decoupling’

- 의존성 주입의 장점
    1. 모듈들을 쉽게 교체 할 수 있는 구조가 되어 테스팅 이 쉽고 마이그레이션이 수월하다
    2. 의존성 방향이 일관되다
    3. 쉽게 추론 가능해진다.
    4. 모듈 간 관계가 명확해진다.
- 의존성 주입의 단점
    1. 모듈이 분리되므로 클래스 수가 늘어나 **복잡성 증가**의 가능성이 있다.
    2. 약간 **런타임 패널티**가 존재한다.
- 의존성 주입 원칙
    
    <aside>
    📌 상위 모듈은 하위 모듈에서 어떤 것도 가져오지 않아야 하며,                                         양쪽 다 **추상화에 의존**해야 하고,                                                                                     이때 추상화는 **세부 사항에 의존 하지 말아**야 합니다.
    
    </aside>
    

## 팩토리 패턴

> 객체를 사용 하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴
> 

상위 클래스가 중요한 뼈대 결정, 하위 클래스가 객체 생성의 구체적 내용을 결정한다.

- 상위 클래스와 하위 클래스 분리로 인해 느슨한 결합을 갖는다. (**유연성이 증가**)
- 객체 생성 로직이 분리 되어 있기에, 리팩터링 시에 한 곳만 고치면 되므로 **유지 보수성 증가**.

```java
//차후 추가

```

⇒ 일종의 의존성 주입이라고 볼 수 있음 (why? 를 생각해보기) page 26 참고.

## 전략 패턴(Strategy pattern)

> **‘직접’ 수정하지 않고, 전략이라고 부르는 ‘캡슐화한 알고리즘’을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴**
> 

예시

- 결제 수단 변경 시 카카오페이, 네이버페이 등을 선택하여 교체 사용하는 것과 같음

```java
//차후 추가
```

관련 라이브러리로 passport가 존재, Node.js에서 인증 모듈 구현 시 주로 사용

## 옵저버패턴

> **주체(관찰자)가 어떤 객체(subject)의 상태 변화를 관찰하다가 상태변화가 있을 시마다 메서드 등을 통해 자신의 옵저버(해당 객체의 상태 변화에 따라 ‘추가 변화 상황’ 이 생기는 객체들) 들에게 변화를 알려주는 패턴**
> 

예시

- 트위터에서 주체가 새로운 트윗을 올리면 팔로우한 유저(옵저버)들에게 알려준다.

 MVC 패턴에 사용

- 모델(주체)의 변경 사항이 생기면 update()를 통해 뷰(옵저버)에게 알려주고 이를 기반으로 컨트롤러 등이 작동한다.

### 자바에서 옵저턴

```java
//자바에서의 옵저버 패턴
```

topic은 주체이자 객체

### 자바: 상속과 구현

상속(extends) - 일반 클래스 및 abstract 클래스 기반

- 자식클래스가 부모 클래스의 메서드 등을 상속받아 사용하며, 추가 및 확장 가능
- 재사용성 증가, 중복성의 최소화

구현(implements) - 인터페이스 기반

- 부모 인터페이스를 자식 클래스에서 재정의하여 구현
- 반드시 부모 클래스의 메서드를 재정의 하여 구현시켜야함.

### 자바 스크립트에서의 옵저버 패턴

- 프록시 객체를 통해 구현
- 프록시 객체 : 대상의 기본적인 동작의 작업을 가로챌 수 있는 객체
    
    프록시 객체의 매개변수
    
    - target: 프록시할 대상
    - handler : target의 동작을 가로채고 어떠한 동작을 할 것인지가 설정되어 있는 함수.

```jsx

```

get() :  속성과 함수에 대한 접근을 가로챈다

has() : in 연산자의 사용을 가로챈다

set() : 속성에 대한 접근을 ‘가로채’서 속성이 변경되는 것을 감시

- 프론트 엔드에서 해당 값이 변경되었을 때 자동으로 DOM 의 값이 변경되는데 이또한 프록시 객체를 이용한 옵저버 패턴이다.

## 프록시 패턴과 프록시 서버

### 프록시 패턴

> 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴
> 
- 보안, 데이터 검증, 캐싱, 로깅에 사용

### 프록시 서버

> 서버와 클라이어트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템, 응용프로그램
> 

ex) nginx - 간접적으로 한 단계를 더 거치도록 설계하여 **보안 강화** 효과

1. 실제 포트를 숨길 수 있고
2. 정적 자원을 gzip 압축
3. 메인 서버 앞단에서의 로깅

ex) CloudFlare

1. DDOS 공격 방어
2. HTTPS 구축(인증서 필요 X)

ex) CORS

## 이터레이션 패턴

> 이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴.
> 

```jsx
//차후 추가
```

## 노출모듈 패턴

> 즉시 실행 함수를 통해 private , public 같은 접근 제어자를 만드는 패턴
> 

접근 제어자가 없는 자바스크립트에서 노출모듈 패턴을 통해 구현함.

## MVC 패턴

> 모델(Model), 뷰(view),컨트롤러(controller)로 이루어진 디자인 패턴
> 

//사진삽입 

- 장점 : 재사용성과 확장성 용이
- 단점 : 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해진다

예) 스프링

### 모델

애플리케이션의 데이터 : 데이터베이스, 상수, 변수 등

### 뷰

사용자 인터페이스 요소 : inputbox, checkbox, textarea 등

- 모델이 가지고 있는 정보를 따로 저장하지 않아야 함
- 변경이 일어나면 컨트롤러에 이를 전댤해야 한다.

### 컨트롤러

하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할

- 이벤트와 같은 메인 로직 담당
- 모델과 뷰의 생명 주기 관리

## MVP 패턴

> MVC 패턴에서 Controller가 프레젠터(presenter)로 교체된 패턴
> 

뷰와 프레젠터는 **일대일 관계**이기 때문에 MVC보다 **더 강한 결합**을 가짐

## MVVM 패턴

> MVC 패턴에서 Controller가 뷰모델(view model)로 교체된 패턴
> 

뷰모델(view model)은 뷰를 더 추상화한 계층

- **커맨드, 데이터 바인딩**
- 뷰와  뷰모델 사이의 **양방향 데이터 바인딩** 지원
- UI를 별도의 코드 수정 없이 **재사용 가능**
- **단위 테스팅이 쉬움**

예시) 뷰(Vue.js)  

# 1.2 프로그래밍 패러다임

//프로그래밍 패러다임 사진 추가

## 선언형과 함수형 프로그래밍

> ‘무엇을’ 풀어내는가에 집중 : “프로그래밍은 함수로 이루어진 것이다”는 명제를 기본으로 함
> 
- 함수형 프로그래밍은 선언형 패러다임의 일종
- 작은 ‘순수 함수’ 들을 블록처럼 쌓아 로직을 구현하고 ‘고차 함수’를 통해 재사용성을 높인 프로그래밍 패러다임
- 예) 자바스크립트

### 순수 함수

> 출력이 입력에만 의존하는 것
> 

```jsx

```

### 고차 함수

> 함수가 **함수를 값처럼 매개변수로 받아** 로직을 생성할 수 있는 것
> 

**일급 객체**

고차 함수를 쓰기 위해서 해당 언어가 일급 객체의 특징을 가져야 한다

- 변수나 메서드에 함수를 할당할 수 있다
- 함수 안에 함수를 매개변수로 담을 수 있다
- 함수가 함수를 반환할 수 있다.

## 객체 지향 프로그래밍

> 객체들의 집합으로 프로그램의 상호 작용을 표현하며, 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식
> 

설계에 많은 시간 소요, 다른 패러다임에 비해 상대적으로 느림

### 객체지향 프로그래밍의 특징

**추상화(abstraction)**

복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것

**캡슐화(encapsulation)**

객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉

**상속성(ingeritance)**

상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나, 확장하는 것

장점 : 재사용성, 계층적인 관계 생성, 유지 보수성

**다형성(polymorphism)**

하나의 메서드나 클래스가 다양한 방법으로 동작하는 것

- 오버로딩 :
    - 같은 이름을 가진 메서드를 여러 개 두는 것(타입,매개변수 유형, 개수)
    - 정적 다형성(컴파일)
- 오버라이딩 :
    - 상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의하는 것
    - 동적 다형성(런타임)

### 설계 원칙

SOLID 원칙

**단일 책임 원칙(S)**

SRP, Single Responsibility Principle

> 모든 클래스는 각각 하나의 책임만 가져야 한다
> 

**개방-폐쇠 원칙(O)**

OCP, Open Closed Principle

> 유지 보수 사항이 생긴다면 코드를 쉽게 확장할 수 있도록 하고 수정할 때는 닫혀있어야 하는 원칙
> 

기존 코드는 변경하지 않으면서, 확장은 쉽게

**리스코프 치환 원칙(L)**

LSP, Liskov Substitution Principle

객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 하는 것

부모 객체 에 자식객체를 넣어도 문제없이 돌아가야 함.

**인터페이스 분리 원칙(I)**

ISP, Interface Segregation Principle

> 하나의 일반적인 인터페이스보다 , 구체적인 여러 개의 인터페이스를 만들어야한다는 원칙
> 

**의존 역전 원칙(D)**

DIP, Dependency Inversion Principle

> 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 원칙
> 

상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립적이어야 한다.

## 절차형 프로그래밍

> 로직이 수행되어야 할 연속적인 계산 과정으로 이루어져 있다
> 

장점

- 코드 가독성이 좋다
- 실행 속도가 빠르다
- 주로 계산 작업에 사용한다.

단점

- 모듈화하기 어렵다
- 유지 보수성이 떨어진다.