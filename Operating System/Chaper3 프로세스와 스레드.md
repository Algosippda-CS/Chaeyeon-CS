# Chaper3

# 3.1 프로세스란 무엇일까?

프로세스 : “ 수행 중인 프로그램( A program in execution)

여기서 수행 중이라는 의미는 어떤 일임을 나타내는 프로그램,

필요한 값들을 저장하고 있는 처리기 레지스터, 

스택 등의 데이터와 함께 얼마 정도가 진행되었는지를 나타내는 PC 값 등으로 표현되어

커널에 등록되어 있다는 것을 모두 합친 뜻

⇒ 프로세스란 **프로그램**과 **데이터**를 기본으로 정상적인 실행을 위해 필요한 **환경**을 시스템으로부터 부여받은 능동적인 존재

아래부터는 프로세스를 “Job” 이라는 단어로 대치하여 표현할 것임

## 3.1.1 프로세스 제어 블록

- 하나의 프로세스가 만들어져 없어질 때까지 시스템에는 ‘PCB’라는 테이블 모양의 자료구조로 존재한다.
- 프로세스 하나가 만들어진다 == 해당 프로세스에 대한 모든 것을 표현하는 PCB 하나가 만들어진다.
- 프로세스는 무수히 많으므로 PCB에 대한 작업은 매우 빈번하므로, PCB는 기본적으로 **메모리에 저장**한다.

운영체제가 프로세스를 관리한다 ⇒ PCB에 대한 다양한 행동(만들고, 수정하고,관련 리스트로 연결하고, 지우고)

PCB에 저장되는 정보

- **프로세스 번호(Process Identification Number, PID)** : 프로세스의 고유한 정수 번호이며 다른 프로세스와의 구별을 위해 사용된다.
- **프로세스의 상태(Status)** : 준비, 실행, 대기, 보류 등의 상태를 나타냄
- **프로세스 우선순위(Priority) :** 스케줄링을 할 때  사용되는 우선순위
- **프로그램 카운터 값 :** 다음에 실행될 명령어의 주소 값
- **메모리 포인터 :** 프로그램과 데이터가 저장되어 있는 메모리 블록 위치와,공유되는 메모리 블록들에 대한 포인터를 포함
- **문맥 데이터** : 문맥교환 시에 CPU 레지스터 값들을 저장하는 영역
- **할당받은 자원들에 대한 목록 :** 개방(Open)한 파일 등 할당받은 자원들의 정보
- **계정 정보(Accounting Information) :** CPU를 사용한 시간 등의 정보
- **입출력 정보. :** 진행 중인 입출력 요구 등의 정보

## 3.1.2 프로세스의 상태(Process State)와 변화

![image](https://github.com/Algosippda-CS/Chaeyeon-CS/assets/61193581/6e12897b-14e6-4f31-91fc-c05d403c7faf)


※CPU 하나라고 가정

- 생성 상태 (Created) : 사용자가 요청한 작업이 커널에 등록되고 PCB가 만들어져 프로세스가 만들어진 다음 준비나 보류 준비 상태로 되기 위해 잠시 거치는 상태
- 준비 상태 (Ready) : CPU를 할당받기 위해 기다리고 있는 상태
    
    CPU만 주어지면 바로 실행할 준비가 되어 있는 상태
    
- 실행 상태 (Running) : CPU를 할당받아 실행 중인 상태
    
    Dispatch(디스패치) : CPU를 할당하는 것
    
- 대기 상태 (Blocked) : 프로세스가 실행되다가 입출력 처리를 요청하거나 , 바로 확보 할 수 없는 자원을 요청하면 CPU를 양도하고 요청한 일이 완료되기를 기다리면서 대기하는 상태
    
    대기 상태 프로세스들 역시 관리를 위해 큐(또는 리스트) 가 사용된다
    
- 종료 상태 (Terminated) : 프로세스가 종료될 때 아주 잠시 거치는 상태
    
    할당되었던 모든 자원들이 회수되고 PCB만 커널에 남아있는 상태
    
- 보류 상태 : 프로세스가 메모리 공간을 뺏기고 디스크로 나가야 하는 상태 =Swapped Out한다
    
    Swapped In : 나중에 다시 메모리로 들어오는 경우
    
    위 두  경우를 스와핑(Swappping)이라 부른다.
    
- 보류 준비 상태(Suspended Ready): 생성된 프로세스가 바로 메모리를 받지 못할 때나, 준비 또는 실행 상태에서 메모리를 잃게 될 때를 위해 필요하다
    
    실행 상태의 프로세스가 CPU를 반납하면서 준비 상태로 바뀔 때 메모리 공간까지 잃어야 하는 경우 
    
- 보류 대기 상태(Suspended Blocked : 대기 상태일 때 메모리 공간을 잃은 상태

---

추가 설명))

**생성 상태 :** 운영체제는 프로세스를 생성 후 메모리 공간을 검사하여 충분한 공간이 있으면 메모리를할당하면서 준비 상태로 바꿔주고, 그렇지 못한 경우는 보류 준비 상태로 만든다

**준비 상태 :** 다중 프로그래밍 시스템의 경우 준비 상태의 여러 프로세스들은 메모리에 적재되어 있으며, CPU를 할당받기를 기다리고 있는데 이들을 위해 큐(또는 리스트)가 사용된다. 

준비 상태의 프로세스들은 순서에 따라 CPU를 할당받으면 실행 상태가 되는데 이때 순서를 정하는 것을 **CPU 스케줄링**이라 부름

**실행 상태 :** 실행 상태의 프로세스는 CPU 스케줄링 정책에 의해 CPU를 뺏길 수 있으며 이 경우 준비 상태로 바뀌게 된다

시간 할당량(Time Quantum)이 소진되어 뺏길 때를 시간종료(Timeout)라고 하는데, 이 경우도 인터럽트가 동원되어 처리된다

실행 상태의 프로세스가 입출력이 필요하게 되어 시스템 호출을 하면 입출력 처리의 종료를 기다리면서 대기 상태로 바뀌고, CPU는 바로 준비 상태의 프로세스들 중에서 하나를 선택해 실행해준다.

**대기 상태 :** 요청한 일 이 완료되면 다시 실행 차례를 기다리기 위해 준비 상태로 바뀌면서 준비 큐에 들어간다.

**종료 상태 : 종료 상태에서** 운영체제가 프로세스의 흔적을 최종 정리 후 PCB를 삭제하면 프로세스가 완전히 사라진다.

<aside>
💡 입출력에 비해 CPU  속도가 매우 빠르다는 사실을 알고 있어야 한다.

</aside>

⇒ 메모리를 꽉 채우고 있는 프로세스들이 전부 입출력 중이라 CPU가 쉬고 있는 상황도 가능

CPU를 가동 시키고 싶다면 먼저 메모리를 확보하고, 입출력 때문에 대기 중인 프로세스들 중 누군가를 보류시켜야 함.

**보류 준비 상태 :** 충분한 메모리 공간의 확보를 위해 준비 상태의 프로세스를 보류시켜야 하는 경우, 높은 우선순위의 보류 대기 상태 프로세스가 준비 상태가 되면서 실행 상태의 프로세스로부터 CPU를 뺏는 경우

메모리에 여유가 생기거나 또는, 준비 상태의 프로세스가 전혀 없을 때 :  대기 상태의 프로세스를 보류 대기로, 만들고 메모리 공간이 확보되면 보류 준비 상태의 프로세스가 준비 상태로 바뀌게 된다

 → 스와핑 발생

**보류 대기 상태 :** 준비 상태의 프로세스가 없어 대기를 보류 대기로 만드는 경우, 

혹은 당시 준비 상태의 프로세스가 있더라도 메모리 여유 공간을 확보하기 위해 보류 대기 상태로 만드는 경우가 있다.

보통 입출력이나 기다리던 사건의 종료 시 보류 준비 상태가 된다.

---

활성 상태(Active State) : 실행될 프로그램과 데이터 등을 위해 메모리 공간의 일정량을 부여받은 상태, 즉 다중 프로그래밍에 포함되는 프로세스들/ 준비, 실행, 대기 상태

보류 (Suspension)하다 : 메모리가 부족하거나 다른 이유에 의해 시스템이 활성 상태의 프로세스로부터 메모리를 회수하는 것

보류 상태는 일차적으로 메모리 공간의 확보를 위해 필요하지만, 다른 이유도 있음

- 실행되는 프로세스의 현재 결과가 바라던 것이 아닌 오류일 때
- 시스템에 위해를 가할 수있는 수상한 행동을 할 때
- 주기적인 일이라서 다음 주기 실행 까지 메모리를 회수해도 문제되지 않을 때 등

# 3.2 스레드란?
![image](https://github.com/Algosippda-CS/Chaeyeon-CS/assets/61193581/23902252-897b-4a2e-afac-62329bdbd382)
프로세스 : 부여된 자원의 소유자

스레드 : 스케줄링의 단위

한프로세스에 속한 각 스레드들은 프로세스가 가지는 자원을 공유하면서 자신의 실행환경(PC값, 스택, 레지스터 값) 을 따로 가진다

다중스레딩(Multi-threading)이란 하나의 프로세스를 다수의 스레드로 만들어 실행하는 것

하나의 프로세스 내에 다수의 실행 단위들이 존재하여 **수행에 필요한 자원들을 공유**하기 때문에 **자원의 생성과 관리가 중복되는 것을 줄일 수 있다**.

## 3.2.1 스레드에 대해 조금 더.

다중 스레딩에서 프로세스란?

- 보호(jprotection)와 자원의 할당 단위가 된다 → 즉, 프로세스의 코드와 데이터를 수용하기 위한 가상 주소 공간과 PU, 다른 프로세스들의 파일들, 입출력에 사용되는 자원에 대한 보호된 엑세스를 보장하기 위한 단위
- 한 프로세스 내의 다수 개의 스레드 각각은 스레드의 수행 상태 를 위한 스레드 문맥, 각자의 실행 스택, 자신이 속한 프로세스가 가지는 메모리와 자원에 대한 접근 권한을 가진다.


![image](https://github.com/Algosippda-CS/Chaeyeon-CS/assets/61193581/e63fedb1-3571-4865-a8f8-682a331fb33f)

- 각 스레드는 PCB와 같은 자신의 제어블록과 스택을 가짐
- 동시에 프로세스 정보인PCB와 사용자 주소 공간을 공유
- 한 스레드에 의해 메모리 데이터가 변경될 경우 다른 스레드들은 변경된 데이터를 사용하게됨

스레드의 장점

- 스레드를 만들고 없애며, 스레드 스위칭에 소요되는 시간과 비용이 프로세스 단위로 이루어질 때 빠르고 저렴하다
- 프로세스 간의 통신은 커널의 개입이 필요하지만, 한프로세스 내 스레드 간 통신은 이미 자원을 공유하기에 커널의 개입이 필요 없다

## 3.2.2 스레드의 상태와 동기화

프로세스와 마찬가지로 실행, 준비, 대기와 같은 상태를 가짐

보류는 프로세스 레벨의 개념이므로 스레드는 없음

대기 : 레지스터 값, PC, 스택 포인터의 보관

종료: 해당 스레드의 레지스터 값들과 스택을 제거

특정 스레드가 변경시킨 내용이 바로 다른 스레드에 영향을 미치므로, 오류를 방지하기 위해 스레드 실행의 동기화가 요구된다.→ 5장에서 자세히 설명

## 3.2.3 스레드의 종류

![image](https://github.com/Algosippda-CS/Chaeyeon-CS/assets/61193581/8efd5471-8403-4c9d-90b6-42aa4f1323de)


### 사용자 레벨 스레드 (User Level Thread)

- 스레드 라이브러리에 의해 관리
- 스레드와 관련되 모든 액티비티는 사용자 공간에서 이루어지므로 커널은 스레드의 존재를 알지 못함.
    
    → 커널은 특정 프로세스에 속한 스레드들 각자가 일으키는 행위를 속한 ‘프로세스의 행위’로 인식한다
    
- 스레드 라이브러리 : 스레드 생성, 소멸 코드 /스레드 간 메시지, 데이터 전달/ 스레드 스케줄링/ 스레드 문맥 보관, 재저장 등을 담당한다.

- 특정 스레드에서 대기는 자신이 소속된 프로세스의 대기를 초래함 (커널은 프로세스만 보이므로) 당시 실행 중이던 스레드는 지금은 실행중이 아니지만 스레드 라이브러리가 실행으로 간주하여(실행중이었음을 표시하는 목적) 나중에 CPU가 해당 프로세스에게 다시 할당 되었을 때 이어서 실행해나갈 수 있도록 해줌
- 다른 예 ) 스레드의 실행 중, 해당 프로세스의 시간 초과가 될 경우 커널은 프로세스의 스위칭을 수행하며, 당시 실행중이던 스레드 역시 실행 상태로 유지되다 해당 프로세스가 CPU를 다시 받게 되면 재실행 된다.
- 사용자 레벨 스레드는 스레드 스위칭 과정에서 커널의 개입이 없다 → 유저에서 커널 모드로 커널에서 유저모드로의 두번의 모드 스위칭이 필요없다.
- 스레드 간 스위칭 시 운영체제 스케줄링에 따를 필요 없고 , 독자적이 스케줄링이 가능하며 어떤 운영체제에서도 운영이 가능하다

단점 

- 특정 스레드의 대기가 자신이 소속된 프로세스 내의 모든 스레드들의 대기를 초래
- CPU는 프로세스 단위로 할당 되기 때문에 다중처리 환경이 주어져도 스레드 단위의 다중처리가 되지 못한다 → 즉 커널이 스레드를 보지 못하기 때문에 여러 스레드들이 서로 다른 CPU를 할당 받아 동시에 진행이 불가능하다.

### 커널 레벨 스레드(Kernel Level Thread)

- 모든 스레드의 관리를 커널이 하는 경우
- 스케줄링은 커널에 의해 스레드 단위로 이루어 지므로 사용자 레벨 스레드의 단점 극복
    
    → 다중 처리 환경에서 한 프로세스 내 다수 스레드는 각각 처리기를 할당 받아 병렬 처리가 가능하며 , 한스레드의 대기 시 같은 프로세스에 속한 다른 스레드로 스위칭이 가능하다
    
- 반면 같은 프로세스에 속한 스레드 간 스위칭에도 커널의 개입이 필요하므로 모드 스위칭이 요구된다는 단점이 있다.

![image](https://github.com/Algosippda-CS/Chaeyeon-CS/assets/61193581/aad5ca35-e121-4e6a-a93b-a18bb3e9dbea)


단일 처리 시스템에서의 작업 비교

- 위 그림은 다른 서버에 있는 프로시저를 호출하고 , 그 다음 또 다른 서버의 프로시저를 호출하는 두번의 순차적인 원격 프로시저 호출(Remote Prjocedure Call, RPC) 수행하는 작업이다.

서버에서 결과를 받을 때까지 ‘기다리는’ 빗금 구간 을 보면 

프로세스는 이 빗금 구간으로 인해 종료 시간이 꽤 늦어지지만 

스레드를 사용할 경우는 첫번째 호출을 한 스레드에게 맡기고 대기가 되면, 다른스레드를 실행시켜 두번째 호출을 하게한다.

⇒ 두 개의 스레드가 대기 중인 시간대가 중복된 만큼 전체 일의 종료 시간이 앞당겨 짐

단일 처리 시스템의 경우에도 스레드를 만드는 것이 프로세스를 만드는 것보다 시간과 비용 면에서 좋다는 사실을 알 수 있다.
