# Chapter5

병행(Concurrent) 이란 ?

: 같이 존재하고 있다

다중 프로그래밍의  병행 → 메모리에 다수의 프로세스가 같이 존재한다는 의미

#병행과 병렬은 다른 뜻이며, 병렬 처리를 위해서는 병행성이 전제되어야 하는 관계이다

비동기적(Asynchronous) : 다른 프로세스들이 어떤 상태에 있는지, 어떤 자원을 가지고 있는지, 어디까지 실행됬는지 등에 대해 병행 프로세스들이 서로 모른 채 실행되고 있음을 의미

# 5.1 병행 프로세스

상황 가정

> “사람들이 옹기종기 모여 사는 작은 산골 마을이 있었는데 땔감을 팔고 생 필품을 사기 위해서는 아랫마을에 가야 했다. 오가는 길 중간에 혼자 간신히 지나갈 수 있는 낡은 나무다리가 있었는데 숲이 우거져 다리 위에 사람이 있 어도 잘 보이지 않았다. 두 사람이 동시에 올라가면 다리가 부서질 것을 대비 해 장치를 하였는데, 양쪽 끝에 팻말을 두고 줄을 연결한 다음 팻말이 내려가 있으면 다리에 사람이 없다고 판단하고 줄을 당겨 팻말을 올린 뒤 다리를 건 넌 후 다시 줄을 당겨 팻말을 내려놓기로 약속하였다. 다리를 건너기 위해 온 사람은 팻말이 올라가 있을 경우 다리 위에 있는 사람이 다 건넌 다음 팻말을 내려줄 때까지 기다려야함은 당연하며 이 약속을 잘 지킨 덕분에 모두 행복하 게 살았다고 한다.”)
> 

위 이야기에서

병행 프로세스 : 산골마을에 함께 살고있는 사람들

비동기적인 관계 : 누가 언제 다리를 건널 것인지는 서로 모름

공유 자원 : 다리

룰 : 한번에 한사람 씩 건너야 한다

**공유된 자원이나 데이터에 대해 병행 프로세스들이 따라야 하는 룰**

<aside>
💡 “ 한 번에 한 프로세스만이 접근 하도록 하고, 해당 자원에 대해 의도했던 실행을 완료하도록 보장한다.”

</aside>

다른 예시

메모리에 있는 변수 count는 현재 값 10

프로세스 A: 이 값을 하나 증가 시키는 일

프로세스 B : 하나 감소시키는 일

즉, 두 프로세스가 한 번씩 실행되었을 때 결과 값은 누가 먼저 실행 되든 여전히 10이어야 한다

A의 경우 

- 메모리에서 count 값을 읽어 처리기 레지스터로 넣은 다음
- 1을 더함
- 처리기 레지스터에 들어 있는 결과 값(11)을 메모리 count 변수에 저장
- 실행 완료

여기서 중요한 점은 결과 값 11이 저장되기 전까지는 메모리의 count 값이 10인 것을 명심하자.

B 역시 1을 뺀다는 것 외에는 A와 동일한 절차를 밟게 될 것이다. 

정상적으로 실행됨을 가정하고 A가 먼저 실행되었을 경우 count는 11이 된 후 B에 의해 다시 10이 될 것이며, 반대로 B가 먼저 실행 되었다면 9가 된 후 A에 의해 10이 될 것이므로 두 경우 모두 정확한 결과를 낳는다.

공유 변수 count에 대해 A와 B가 아무 제약 없이 실행할 경우

- 먼저 A가 count 값을 11로 증가시킨 후
- 저장하기전 에 (스케줄링에서 배운 시간 종료나 우선순위 등과 같은 이유에 의해)  CPU의 사용권이 B에게 넘겨진 후,
- B의 count에 대한 접근이 허용되면 B는 1을 빼기 위해 먼저 메모리에 있는 count 값을 읽음,  이때의 값은 여전히 10
- B에 의해 9가 저장된 후 다시 A가 실행되면 이전에 CPU를 뺏긴 시점부터 시작
- 결과적으로 처리기 레지스터에 있는 값 11을 저장하게 되어
- count의 최종 값은 11
- 반대로 A와 B의 순서를 바꾸면 9 가 저장

 다중처리 시스템의 경우에는 두 프로세스가 동시에 실행될 수 있으므로 둘 다 10을 읽고 각자의 실행 결과를 저장하게 될 것이고, 결국 count의 최종 값은 조금이라도 늦게 저장하는 프로세스의 결과 값과 같이 11 또는 9가 될 것이다. 즉, 한 프로세스의 공유 변수 count에 대한 조작 도중 다른 프로세스에게도 coun 대한 조작이 허용되면 부정확한 결과 값을 초래한다

⇒ 단일 처리 시스템의 경우 정확한 결과 값을 위해 A의 count에 대한 조작 도중 CPU가 B로 넘겨 져도 B의 count에 대한 조작은 허용되어서는 안된다.

# 5.2 상호배제

경쟁 상태(Race Condition) : 프로세스들이 공유 데이터에 대해 서로 접근을 시도하는 상황

경쟁상태의 프로세스 가 초래하는 문제

- 상호배제
- 교착상태(Deadlock)
- 기아(Starvation)

상호배제

임계자원(Critical Resource) : 두 개 이상의 프로세스가 동시에 사용할 수 없는 자원

임계 영역(Critical Section) : 임계 자원에 대해 접근하고 실행하는 프로그램 의 코드 부분

ex) 이전의 예시에서 A와 B가 자신의 프로그램 내 count 변수를 조작하는 코드 부분이 임계 영역

상호배제 : 한번에 하나의 프로세스만이 임계영역에 들어가야 함

임계영역의 성공적 실행을 위해서 

1. 상호배제가 제일 먼저 지켜져야 한다. 
2. 임계영역에 잇지 않는 프로세스가 다른 프로세스의 임계영역 진입을 막지말 것 
3. 비어 있는 임계영역에 대한 진입은 바로 허용하되, 특정 프로세스의 진입 시도가 계속 무산되어 기아를 겪지 않도록 해야함.

임계 영역 내 드러가고자 하는 프로세스의 절차

1. 임계 영역 내 다른 프로세스가 있는지 확인한다.
2. 있다며 기다리고, 없다면 들어가면서 , 자신이 나올 때까지 다른 프로세스가 들어오지 못하도록한다
3. 임계 영역을 벗어날 때, 자신이 나오는 사실을 알려 다른 프로세스가 들어올 수 있도록 한다.

⇒ 임계영역을 진입할 때와 나올 때 꼭 해야 하는 일들을 어떻게 잘 구현해서 프로그램 내의 임계영역 앞뒤에 적절하게 코딩해 주느냐가 상호배제의 성공 여부를 결정

상호배제 의무는 프로그래머에게 있지만, 운영체제는 사용자 상호배제 구현을 지원하기 위한 구조로 ‘ 모니터 ‘ 같은 도구를 제공한다.

# 5.3 상호배제를 위한 소프트웨어 기법들

운영체제의 지원 없이 프로세스들 간의 자신의 프로그램에서 임계영역 앞뒤로 적절한 코딩을 해주어 상호배제를 해결하는 방식.

## 5.3.1 몇 가지 미완성 시도들

첫 번째 시도

![Untitled](Chapter5%201df249810ad64a5b83af138fbc4dc91f/Untitled.png)

허점 : 

1. 임계영역의 첫 진입은 P0만 가능하다(turn 초기값이 0임), 임계 영역의 첫번째 진입이 고정된다는 문제점 존재 
    
    → 임계영역이 비어있을 경우 진입을 원하는 프로세스를 방해해서는 안 된다는 원칙에 위배
    
2. turn 값을 바꾸어줌으로써 임계영역 진입이 가능하므로 P0와 P1은 정확하게 한 번 씩 번갈아가면서만 진입이 가능하고, 연속해서 두 번 이상 진입 할 수 없다.
    
    →많은 횟수의 진입이 요구되는 프로세스는 상대 프로세스가 그 횟수 만큼 진입해 주어야함, 
    
    상대 프로세스가 먼저 종료될 경우 자신도 더 이상 임계 영역에 들어갈 수 없는 문제 발생
    
    상대적으로 실행 속도가 느린 프로세스의 속도에 의존적이게 됨
    

두 번째 시도

![Untitled](Chapter5%201df249810ad64a5b83af138fbc4dc91f/Untitled%201.png)

개선점 

1. 최초 진입 제한이 없어짐
2. 상대적으로 많은 횟수의진입이나 상대 프로세스가 먼저 종료되도 진입 가능

문제점

- P0가 flag[1]을 검사한 후 while문을 벗어난 다음 fla[0]을 true로 만들기 전에 P1에게 CPU가 넘어가 버리면, P1 역시 while문을 벗어나 임계영역을 들어가게 되고, 실행 도중 다시 CPU 가 P0에게 넘어갔을 때 P0는 이전에 중단되었던 작업인 flag[0]을  true로 만드는 것부터 실행한 후 임계여영ㄱ으로 진입하게 된다. → ‘둘 다 임계 영역에 위치” , 상호배제 실패
- 다중 처리의 경우라면 , 동시에 while문을 검사한 후 둘다 각자의 flag를 true로 만든 다음 임계영역으로 같이 진입할 위험이 있으므로, 상호배제 실패이다.

두번째 시도의 문제 분석 및 세 번째 시도

- 각자의 flag를 true로 만드는 작업이 while문 다음에 있었기 때문에 실패 했으므로,
    
    이 작업을 while문 앞으로 옮겨준다
    
    → 여전한 문제, P0가 flag[0]을 true로 만들고, CPUI가 P1에게, P1은 flag[1]을 true로 만든 다음 while문에서 만들다 다시 P0에게 CPU가 간다면 P0역시 while문에서 맴돌게 된다
    
    ⇒ 두 프로세스 모두 영원히 임계영역을 들어갈 수 없게 된다.
    

## 5.3.2 성공적인 기법들

**Peterson 알고리즘(Dekker 알고리즘의 개선버전)**

```
void P0()
{
	While (true)
	{
		flag[0] = true;
		turn = 1;
		While (flag[1] && turn ==1); /* do nothing*/
		<critical section>;
		flag[0] = false;
		<remainder>;

	}
}
```

```
void P1()
{
	While (true)
	{
		flag[1] = true;
		turn = 0;
		While (flag[0] && turn == 0); /* do nothing*/
		<critical section>;
		flag[1] = false;
		<remainder>;

	}
}
```

## 5.3.3 n프로세스 간의 상호배제를 위한 소프트웨어 기법들

이전의 Dekker 와 Peterson 알고리즘은 ‘두 프로세스’ 간 상호배제를 해결한 것

더 많은 다수의 프로세스들 사이의 상호배제를 해결해보자

**Lamport 의 베이커리 알고리즘**

가정 : 모든 number 값과 choosing 값은 0과 false로 초기화 되어있고, 

진입을 원하는 프로세스 i는 먼저 number 값이 주어진다 (가장 큰 값)

아래는 임의의 프로세스 i를 위한 프로그램이다.

```
do {
	choosing[i] = true;
	number[i] = max(number[0],number[1],...,number[n-1])+1
	choosing[i] = false;
	for ( j = 0; j < n; j++ )
	{
			while(choosing[j]); //번호 값을 받는 중인 프로세스가 있다면 그 값도 비교하기위해 기다린다
			while((number[j] != 0 && ((number[j],j) < (number[i],i))); // 자신의 값이 가장 작을 때, 임계 영역 진입이 허가된다.
	} 
	<critical section>;
	number[i] = 0 ; //임계영역을 벗어난 후 자신의 값을 0으로 해주어, 다른 프로세스에게 임계영역 진입 기회 부여
	<remainder>;
} while(1);
```

번호 값에 의해 차례가 정해지므로 특정 프로세스의 무한 대기는 없다.

---

소프트웨어 기법은 운영체제의 지원없이 프로세스간 협력을 통해 상호배제를 실현하므로,

실행 부하가 크며, 실수로 인한 오류의 가능성이 크다.

특히, 임계 영역 중복 진입을 막기위해 while문을 계속 맴돌게 하는건 CPU를 낭비하므로

바쁜 대기(Busy Wait),  스핀락(SpinLock)을 초래한다.

# 5.4 상호배제를 위한 하드웨어 기법들

## 5.4.1 인터럽트 금지를 사용한 기법

인터럽트 금지는 처리기 단위 이므로 다중처리 시스템에서는 해당 cpu만 금지시키므로 여전히 다른 처리기 프로세스의 접근 가능성이 존재하므로 사용하기 힘든 방식

```
While (true) do
.
.
Interrupt Disable;
	<critical section>;
Interrupt Enable;
.
.
endWhile;

```

메모리의 같은 위치에 대한 읽기와 쓰기, 또는 읽기와 검사같은 일을 한 명령어 사이클( 한접근) 동안 처리해주는 명령어가 있다면, 이런 종류의 기계 명령어는 다른 접근 요청이 차단된 가운데,

원자적(Atomic)이고, 실행동안 끊기지 않고(Indivisible) 완료될 수 있다.

## 5.4.2 하드웨어 명령어를 사용한 기법

```
boolean testandset(boolean &target)
	{
	boolean rv = target;
	target = true;
	return rv;
	}
```

```
void exchange (boolean &r, boolean &m)
		{
		boolean temp = r;
		r = m;
		m = temp;
		}
```

위에서 말한 기계 명령어 testandset/ exchange(swap) 

```
const int n=...;/*프로세스 개수 */
boolean lock;
void P(int i);
{
	while (true)
	{
		while (testandset(lock));
		<critical section>;
		lock:=false;
		<remainder>;
	}
}
void main()
{
	lock:=false;
	parbegin
		P(1), P(2),...,P(n);
	parend;
}
(a)
```

testandset과 exchange를 사용한 상호배제

```
const int n=...; /*프로세스 개수 */
boolean lock;
void P(int i);
{
	while (true)
	{
		key = true;
		while (key = true) do exchange(key, lock);
		<critical section>;
		lock := false;
		<remainder>;
	}
}
void main()
{
	lock:=false;
	parbegin
		P(1), P(2),...,P(n);
	parend;
}
(b)
```

(a) 에서 lock 초기 값이 false 이므로 최조 진입 프로세스가 testandset을 실행하면, 

target 값이 false가 되어 rv로 넘겨져, while 문은 false가 된다. 

결과적으로 임계영역 진입이 가능해진다.

임계영역을 실행 중인 프로세스가 있다면,

 lock 값이 true이므로 진입을 시도하는 다른 프로세스들이while문에서 맴돌게 되므로써 

상호배제를 보장한다.

기계 명령어를 활용하면 간단하고, 다중 처리 시스템에서도 쓸 수 있다. 

- 여러 개의 임계 영역도 지원이 가능하다
- 여전히 바쁜 대기 존재
- 차례가 안정해져, 기아가 발생가능
- 임계영역 실행중 높은 우선순위를 가지는 프로세스에게 cpu를 뺏기면, 교착 상태에 빠질 수 있다.

# 5.5 세마포어

Kijkstra 가 1965년 제안한 개념

- 세 개의 특 수한 명령들만 접근할 수 있게 허용되는 보호된 변수
- 더 높은 수준에서의 상호배제
- 이진 세마포어 : 세마포어가 0or 1의 값만을 가질때
- 계수 , 정수 세마포어 : 음이아닌 모든 정수 값을 가질 때
- 세마포어 명령은 ‘비분리’ 명령임
- 초기화 명령, P 명령(wait), V 명령(signal)
- 같은 세마포어에 대해서 동시에 실행되지 못함( P와 V는 동시에 실행 X)
- 

**세마포어의 정의**

```
P(S) : **if** (S > 0) **then** S = S-1;
									**else** S > 0 조건이 만족될 때까지 큐에서 대기
V(S) : **if** ( 큐에서 대기 중인 프로세스들이 존재)
									**then** 그 중의 한 프로세스를 준비 또는 실행 상태로 만듦;
									**else** S = S + 1;
```

O/S가 개입하여 block & wakeup 방식

장점 : cpu를 block 하자마자 다른 프로세스를 running 시켜 cpu 낭비가 없음

단점 : 조건이 만족되도 일단 wakeup 시켜 ready 상태로 만들어 줘야함, 이 때 ready 상태의 타 프로세스들과 경쟁해서 cpu를 부여받는다, 즉, wakeup 해도 바로 cpu를 받아 running할 수 있진 않다 

→ 즉각적인 반응이 느려진다 & 커널 개입 필요 (CPU time을 o/s 가 써야함)

**바쁜대기를 이용한 구현 방식**

```
P(S) {
				while ( S <= 0 ); /* busy -wait */
				S --;
			}
V(S) {
				S ++;
			}
```

장점 : wait 하던 상황이 만족되면 즉시 해당 프로세스는 다음 while문 test 후 바로 critical section 진입한다

단점 : CPU를 계속 wait 시켜 다른 프로세스에게 넘겨도 되는 상황임에도 cpu 낭비

이진 세마포어를 사용한 상호배제

```
**const int** n = /*프로세스의 수*/;
**semaphore** s  = 1; //정수 세마포어 예시 (출력 작업) : S->10
**void** p(int i)
{
	**while** (true)
	{
		P(s); // ->S가 0이 되는 순간 프린터 10대가 다 돌아가고 있음.
		<critical section>;
		V(s);
		<remainder>;
	}
}
**void main**()
{
	**parbegin**
		p(1),p(2),...,p(n)
	**parend**
}
```

설명

- 최초 세마포어 변수가 1로 초기화 되어있다.
- 최초로 진입을 시도하는 프로세스는 S를 0으로 바꾸고 진입한다
- 이 후 진입을 시도하는 프로세스들은 S가 0이기 때문에 대기 상태가 된다.
- 임계 영역을 나오는 프로세스에 의해 다시 S는 1이된다
- 대기 상태의 프로세스 중 하나가 실행 가능한 상태가 되어 임계 영역이 가능해진다
- 반복.

⇒ 세마포어는 상호배제 뿐만아니라 프로세스 간 진행이 ‘서로 의존적’ 이기에 **동기화**에도 유용하다

# 5.6 생산자-소비자 문제

병행 프로세스의 상호배제와 동기화 에 대한 고전 문제

생산자 : 데이터를 만들어 버퍼에 저장(채워나감)

소비자 : 버퍼에 있는 데이터를 꺼내 소비(비움)

버퍼 : 공유 자원 → 상호배제 필요

버퍼가 비어 있을 때 소비자가,꽉 차있을 때는 생산자가 기다려야하는 동기화도 포함

- n 개 유한 원형 버퍼를 가정

```
생산자:
while( true )
{
	create data V;
	while ((in+1) % n == out); // 버퍼가 꽉차 있다면
	buffer[in] = V; //append data
	in = (in+1) % n;
}
```

```
소비자:
while( true )
{
	while (in == out); // 버퍼가 완전히 비어있다면
	W = buffer[out]; //append data
	out  = (out + 1) % n;
	consume data W;
}
```

```
**semaphore** s = 1;
**semaphore** f = 0;
**semaphore** e = n; // buffer size
**void** producer()
{
	**while**(true)
	{
		produce data V;
		P(e);
		P(s);
		append data V;
		V(s);
		V(f);
	}
}
**void** consumer()
{
	**while**(true)
	{
		p(f);
		P(s);
		take data W;
		V(s);
		V(e);
		consume data W;
	}
}
**void main**()
{
	**parbegin**
		producer(),consumer();
	**parend**
}
```

- 무한 버퍼를 가정한 알고리즘이 필요한 경우 e에 대한 선언과 명령어 부분만 빼버리면 된다.

단점⇒ 세마포어는 여전히 특정 프로세스들의 기아를 유발할 수 있다

# 5.7 Eventcount와 Sequencer를 사용한 기법

```
생산자 i:
var pord : integer; // 생산자 순서
while (true) {
	create data V; //데이서 생산
	portd = ticket(p); // 번호를 부여받음
	await(in, pord); //내 차례까지 기다림
	await(out, pord-n+1); //내 차례
	buffer[pord % n ] = V; //해당자리에 넣음
	advance(in); //포인터 1 증가
}
```

```
소비자 j:
var cord : integer;
while (true) {
	cord = ticket(c); //번호 부여
	await(out, cord); //차례 기다림
	await(in, cord + 1); //버퍼가 완전히 비었으면 기다림
	W = buffer[cord % n}; //데이터 받아옴
	advance(out); // 포인터 1 증가
	consume data W; //데이터 소비
}
```

- Eventcount 와 Sequencer는 정수형 변수이며 초기 값 0, 그 값이 감소하지 않는다
- ticket(s)는비분리 명령이며, sequencer 변수인 s 값 반환
- ticket(s)는 실행 될 때마다 s값이 1 증가
- Eventcount에 대한 명령 : 비분리 X
    - read(E) : 현재의 E 값 반환
    - advance(E) : E를 1 증가
    - await(E) : E가 v값보다 작으면 기다리도록 함
- 장점 : 임계영역 진입을 시도하는 프로세스에게 순번 표를 부여하여, 순서대로 처리되게 함으로 기아를 방지한다.
- 예시 ) 은행 창구
- 단점 : 사용자가 구사하며 실수 할 가능 성이 있다.