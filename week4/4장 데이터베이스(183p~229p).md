# 4장(183p~229p)

# 4.1 데이터 베이스의 기본

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled.png)

데이터 베이스 : 일정한 규칙, 혹은 규약을 통해 구조화 되어 저장되는 데이터의 모음

DBMS :  해당 데이터베이스를 제어, 관리하는 통합 시스템

DBMS의 쿼리 언어를 통해 데이터들의 삽입, 삭제,수정, 조회가 가능함..

- 데이터 베이스는 **실시간 접근**과 **동시 공유**가 가능

## 엔터티

엔터리(entity) : 사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사

회원 엔티티 = (속성목록) 이름, 아이디 , 주소 , 전화번호

→ 속성은 서비스 요구 사항에 맞춰 정해지는데 , 주소라는 속성이 서비스 요구 사항과 무관한 속성이라면 주소라는 속성은 사라지게 된다

**약한 엔터티 와 강한 엔터티**

A가 혼자서는 존재하지 못하고 B의 존재여부에 종속적이면, A는 약한 엔터티 B는 강한 엔터티

ex) 건물 : 강한 엔터티, 방 : 약한 엔터

## 릴레이션

**릴레이션(relation)** : 데이터베이스에서 정보를 구분하여 저장하는 기본 단위

→ 데이터 베이스는 엔터티에 관한 데이터를 릴레이션 하나에 담아서 관리

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%201.png)

릴레이션

관계형 데이터베이스 에서는 ‘**테이블**’, 

NoSQL 데이터베이스에서는 ‘**컬렉션**’ 이라고 부름.

### 테이블과 컬렉션

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%202.png)

관계형 데이터 베이스(MySQL)  구조 : 레코드 →테이블 → 데이터베이스

NoSQL 데이터 베이스 (MongoDB) 구조 : 도큐먼트 → 컬렉션 → 데이터베이스

## 속성

**속성(attribute)** : 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보

ex_차의 속성) 차넘버, 바퀴 수 , 차 색, 차종 등등

## 도메인

**도메인(domain)** : 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합

ex_속성_성별_도메인) {남, 여} 

## 필드와 레코드

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%203.png)

엔터티 : 회원

테이블 : member

속성 : 이름, 아이디 등등등

필드 : name,ID, address, etc,…

레코드(튜플) : 행 단위 데이터

### **필드 타입**

타입은 DBMS마다 다르다

- **숫자 타입**
    
    
    - **TINYINT**
    - **SMALLINT**
    - **MEDIUMINT**
    - **INT**
    - **BIGHT**
    
    ![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%204.png)
    
- **날짜 타입**
    - **DATE** : 날짜 부분은 있지만, 시간 부분은 없는 값 {3byte}
        - ex)1000-01-01〜9999-12-31
    - **DATETIME** : 날짜 및 시간 부분을 모두 포함하는 값 {8byte}
        - ex) 1000-01-01 00：00：00~ 9999-12-31 23：59：59
    - **TIMESTAMP** : 날짜 및 시간 부분을 모두 포함하는 값 {4byte}
        - ex)1970-01-01 00：00：01~ 2038-01-19 03：14：07
- **문자 타입**
    - **CHAR : 고정 길이 문자열, 0~255, 괄호 안에 수를 입력하여 몇 자 까지 입력할지 지정**
        - EX)CHAR(30)
    - **VARCHAR : 가변 길이 문자열, 0~65535, 입력된 데이터에 따라 용량을 가변시켜 저장**
        - EX)10글자 이메일을 저장할 경우 {10글자에 해당하는 바이트} + {길이 기록용 1바이트}
    
    <큰 데이터를 저장하는 타입>
    
    - **TEXT :  게시판 본문 저장**
    - **BLOB:  이미지, 동영상**
        - EX) 보통은 서버에 파일을 올리고, 파일에 관한 경로를 VARCHAR로 저장
    
    < 문자열을 열거한 타입>
    
    장점: 공간적으로 이득
    
    단점: 정의한 목록을 수정해야 할 수도 있음.
    
    - **ENUM**
        - ENUM(‘x—small’, small’, ‘medium’, ‘large’, ‘x—large’) 형태
        - 단일 선택만 가
        - 0,1 등으로 매핑되어, 메모리를 적게사용함
        - 최대 65,535 개의 요소들을 넣을 수 있음.
    - **SET**
        - ENUM과 비슷하나 여러 개의 데이터를 선택 가능
        - 비트 단위의 연산 가능
        - 최대 64개 요소를 집어넣을 수 있음

## 관계

데이터베이스의 여러 개의 테이블들은 서로의 관계가 정의되어있다.

이 관계를 ‘관계화살표’로 나타낸다

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%205.png)

### 1:1관계

유저와 유저 이메일의 관계

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%206.png)

### 1:N관계

유저와 상품의 관

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%207.png)

### N:M관계

학생과 강의의 관계

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%208.png)

중간에 학생_강의라는 테이블이 끼어있다

⇒ 테이블 두 개를 직접 연결하지 않고, 1:N, 1:M관계를 갖는 테이블 두 개로 나눠서 설정

## 키

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%209.png)

### 기본키(Primary Key)

- PK 또는 프라이머리키 라 부름
- 유일성과 최소성을 만족
    - 중복이 되는 키는 기본키가 될 수 없음
    - 복합키도 유일성을 만족하나 최소성을 만족하지 않아 기본키가 될 수 없음
- 자연키 또는 인조키 중에 골라서 설정.
- **자연키**
    - 중복되지 않는 것을 ‘자연스레’ 뽑다가 나오는 키
    - 언젠가 변하는 속성
- **인조키**
    - 인위적으로 부여한 ‘유저 아이디’ 같은 것 ⇒ 고유 식별자 역할
    - 변하지 않음
    - 기본키는 보통 인조키로 설정

### 외래키(Foreign Key)

- FK 라고도 함
- 다른 테이블의 기본키를 참조하는 값
- 개체 간 관계 식별에 사용
- 중복 가능

### 후보키(candadate key)

- 기본키가 될 수 있는 후보들
- 유일성과 최소성을 동시에 만족

### 슈퍼키

- 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키

### 대체키(alternate key)

- 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키

# 4.2 ERD와 정규화 과정

## ERD의 중요성

- 데이터 베이스는 ERD를 기반으로 구축
- 디버깅 또는 비즈니스 프로세스 재설계가 필요한 경우 설계도 역할 담당
- 장점 : 관계형 구조로 표현할 수 있는 데이터를 구성하는데 유용
- 단점 : 비정형 데이터를 충분히 표현할 수 없음

<aside>
❓ **— 비정형 데이터**                                                                                                                     비 구조화 데이터를 말하며, 미리 정의된 데이터 모델이 없거나 미리 정의된 방식으로 정리되지 않은 정보를 말함.

</aside>

## 예제로 배우는 ERD

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%2010.png)

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%2011.png)

## 정규화 과정

**정규화 과정** : 릴레이션 간의 잘못된 종속 관계로 인해 데이터베이스 이상 현상이 일어나, 이를 해결하거나, 저장 공간을 효율적으로 사용하기 위해 **릴레이션을 여러 개로 분리하는 과정**

데이터 베이스 이상 현상 ex) 회원이 한 개의 등급을 가져야 하는데 , 세 개의 등급을 갖거나 , 삭제 시 필요한 데이터가 같이 삭제되고, 데이터를 삽입해야 하는데 하나의 필드 값이 NULL이 되면 안 되어서 삽입하기 어려운 현상.

**졍규형(NF, Normal Form)**  : 

- 기본 정규형 : 제1정규형, 제2정규형, 제3정규형, 보이스/코드 정규형
- 고급 정규형 : 제4정규형, 제5정규형

### 정규형 원칙

- 같은 의미를 표현하는 릴레이션이지만 좀더 좋은 구조로 만들어야 함
- 자료의 중복성은 감소해야함
- 독립적인 관계는 별개의 릴레이션으로 표현해야 함
- 각 릴레이션은 독립적인 표현이 가능해야 함.

### 제1정규형

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%2012.png)

- 모든 도메인이 더 이상 분해될 수 없는 원자 값으로만 구성되어야 함
- 한 개의 기본키에 대해 두개 이상의 값을 가지는 반복 집합이 있어서는 안됨.
- 반복 집합이 있다면 제거해야 함.

### 제2정규형

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%2013.png)

- 릴레이션이 제1정규형이며, 부분 함수의 종속성을 제거한 형태
- **부분 함수의 종속성 제거**:  기본 키가 아닌 모든 속성이 기본 키에 **완전 함수 종속**적인 것
- 릴레이션을 분해 할 때 동등한 릴레이션으로 분해해야 하고, 정보 손실이 발생하지 않는 무손실 분해로 분해되어야 함.

### 제3정규형

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%2014.png)

- 제2정규형이고, 기본키가 아닌 모든 속성이 이행적 함수종속(trainsitive FD)을 만족하지 않는 상태

**이행적 함수 종속**

A —> B와 B — C가 존재하면 논리적으로 A — C가 성립, 이 때 집합 C가 A에 이행적으로 함수 종속이 되었다고 말함.

### 보이스/코드 정규형

- 제3규형이고, 결정자가 **후보키가 아닌 함수 종속 관계를 제거**하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태

<aside>
❓ **— 결정자**
함수 종속 관계에서 특정 종속자(dependent)를 결정짓는 요소, ‘X今Y’일 때 X는 결정자, Y는 종속자이다.

</aside>

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%2015.png)

- 후보키 :  {학번, 수강명} 또는 {학번, 강사}
- 범석이라는 강사가 ‘롤’ 수강명을 담당할때 이를 삽입하면 학번이 NULL이되는 문제점 발생
- 

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%2016.png)

- 강사 속성이 결정자이지만, 후보키가 아니므로 강사 속성을 분리해야함.

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%2017.png)

# 4.3 트랜잭션과 무결성

## 트랜잭션

트랜잭션: 

- 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위
- 여러 개의 쿼리들을 하나로 묶는 단위를 뜻함.
- ACID 특징 : 원자성, 일관성, 독립성, 지속성

### 원자성(atomicity)

<aside>
💡 **“all or nothing”**

</aside>

- ***트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징***
- ex)트랜잭션을 커밋했는데, 문제가 발생하여 롤백하는 경우 그 이후에 모두 수행되지않음을 보장
    - 작업
        1. 홍철의잔고를 조회한다.
        2. 홍철에게서 500만 원을 뺀다.
        3. 규영에게 500만 원을 넣는다.
    
    → 해당 작업 중에 ‘취소’ 한다햇을때, 홍철이는 다시 1000만원, 규영이는 0원을 가져야함
    
    일부 operation만 적용된 상태에서 정지되어 , 홍철이는 500만원, 규영이는 0원이 되어선 안됨
    
    ⇒ all or nothing
    
- 트랜잭션 단위로 여러 로직들을 묶을 때 외부 API 를 호출하는 것이 있으면, 안됨
    
    만약 있다면 “롤백이 일어났을 때 어떻게 할 것인지에 대한 해결 방법” 이 있어야 하고
    
    트랜잭션 전파를 신경써서 관리해야 한다
    

**커밋과 롤백**

커밋(commit) : 

- 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령
- 트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장되는 것
- 커밋 수행 = 트랜잭션 하나가 성공적으로 수행됨

롤백 :

- 에러나 이슈 때문에 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일(취소)

⇒ 커밋과 롤백 덕에 데이터의 **“ 무결성 “** 보장

**트랜잭션 전파**

트랜잭션 수행 시 커넥션 단위로 수행하기 때문에, 커넥션 객체를 넘겨서 수행해야한다

그러나 매번 넘겨주기는 어렵고 귀찮다. → 트랜잭션 전파이용

트랜잭션 전파 : **여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것**

```java
©Service
©Transactional(readonly = true)
public class MemberService {
	private final MemberRepository memberRepository；

	public MemberService(MemberRepository memberRepository) {
		this.memberRepository = memberRepository；
	}
```

@Transational 애터테이션을 통해 여러 쿼리관련 코드들을 하나의 트랜잭션으로 처리

### 일관성

- ***‘허용된 방식’ 으로만 데이터를 변경해야하는 것***
- 데이터 베이스에 기록된 데이터는 여러 조건, 규칙에 따라 유효해야 함격리성(isolation)

### 격리성(isolation)

- ***트랜잭션 수행 시 서로 끼어들지 못함***
- 복수의 병령 트랜잭션은 서로 격리되어있지만, 마치 순차적으로 실행되는 것처럼 작동해야 하고, 데이터 베이스는 여러 사용자가 같은데이터에 접근 가능해야함 → 순차적으로 동작하는 건 성능이 나쁘므로, 격리성을 여러 수준으로 나누어 보장한다.

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%2018.png)

<격리 수준에 따라 발생하는 현상>

**팬텀리드(phantom read)**

- 한 트랙잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우
- ex)  사용자 A가 age12 이상인 회원 조회 쿼리를 보냈는데,세 개 테이블이 조회되었다 , 그다음 사용자 B가 age 14인 회원 레코드를 삽입해, 기존 세 개 가 아닌 네 개의 테이블이 조회되는 경우

**반복 가능하지 않은 조회(non-repeatable read)**

- 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우를 가리킴
- 사용자 A가 가진 큰돌의 보석 개수가 100 값을 가졌었는데, 그 이후 사용자 B가 값을 1로 변경해서 사용자 A는 100이 아닌 1을 읽게됨
- 팬텀 리드 와 차이 : 반복 가능하지 않은 조회는 행 값이 달라질 수 있는데, 팬텀리드는 다른 행이 선택 될 수도 있다는 것을 의미

**더티 리드(dirty read)**

- 반복 가능하지 않은 조회와 유사
- 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 ‘ 커밋되지않은’ 행의 데이터를 읽을 수 있을 때 발생
- 사용자 A가 큰돌의 보석 개수 100을 1로 변경한 내용이 ‘ 커밋되지 않은 ‘ 상태여도 사용자 B가 조회한 결과가 1로 나오는 경우

### 격리 수준

SERIALIZABLE

- 트랜잭션을 순차적으로 진행시키는 것
- 여러 트랜잭션이 동시에 같은 행에 접근할 수 없다
- 매우 엄격
- 해당 행에 대해 격리 후, 트랜잭션이 이행에 대해 일어난다면 기다려야 함
    
    ⇒ 교착 상태 가능성 큼, 성능 가장 떨어짐
    

REPEATABLE_READ

- 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막지만
    
    새로운 행을 추가하는 것은 막지 않음
    
    ⇒ 이후에 추가된 행이 발견될 수도 있음(반복가능하지 않은 조회 발생가능)
    

READ_COMMITTED

- 기본값으로 가장 많이 사용되는 격리 수준
- READ_UNCOMMITTED와 달리 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없음
- 커밋 완료된 데이터에 대해서만 조회 허용
- 어떤 트랜잭션A이 접근(수정 등) 중인 행을 다른 트랜잭션B이 수정 가능
    
    ⇒ 트랜잭션 A가 같은 행을 다시 읽을 때 다른 내용이 발견될 수도 있음
    

READ_UNCOMMITTED

- 가장 낮은 격리 수준
- 하나의 트랜잭션이 커밋되기 전에, 다른 트랜잭션에 노출되지만, 가장 빠름
- 데이터 무결성을 위배해 되도록 사용하지 않기
    
    ⇒ 몇몇 행이 제대로 조회되지 않아도 괜찮은 거대한 데이터를 ‘어림잡아’ 집계 시 사용
    

### 지속성(durability)

- 성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것
- 데이터 베이스에 시스템 장애가 발생해도 복구하는 기능이 있어야함.
    
    ⇒체크섬, 저널링, 롤백 기능 제공
    

<aside>
❓ **— 체크섬**
중복 검사의 한 형태로, 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법

</aside>

<aside>
❓ **— 저널링**
파일 시스템 또는 데이터베이스 시스템에 변경 사항을 반영(commit)하기 전에 로깅하는 것, 트랜잭션 등 변경 사항에 대한 로그를 남기는 것

</aside>

## 무결성

- 데이터의 정확성, 일관성, 유효성을 유지하는 것
- 무결성이 유지되야 데이터베이스 저장된 값과, 그 값의 현실 세계의 실제 값이 일치하는지에 대한 신뢰가 생김

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%2019.png)

# 4.4 데이터 베이스의 종류

## 관계형 데이터베이스

행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스, SQL이라는 언어를 써서 조작

ex) MySQL, PostgreSQL, 오라클, SQL Server, MSSQL

### MySQL

- 대부분의 운영체제와 호환
- 현재 가장 많이 사용됨
- C,C++ 로 구성,
- MylSAM 인덱스 압축 기술, B-트리 기반의 인덱스, 스레드 기반의 메모리 할당 시스템, 매우 빠른 조인, 최대 64개의 인덱스 제공
- 대용량 데이터베이스를 위해 설계되어있음
- 롤백, 커밋, 이중 암호 지원 보안 기능 제공
- 모듈식 아키텍쳐로 쉽게 스토리지 엔진 교체가능
- 강점 : 데이터 웨어하우징, 트랜잭션 처리, 고가용성 처리

### PostgreSQL

- MySQL 다음으로 선호됨
- VACUUM이 특징 : 디스크 조각이 차지하는 영역 회수 장치
- 지정 시간에 복구하는 기능, 로깅, 접근 제어, 중첩된 트랜잭션, 백업 기능 제

## NoSQL 데이터베이스

Not only SQL 슬로건에서 생겨남

### MongoDB

- json을 통해 데이터에 접근
- Binary JSON 형태（BSON）로 데이터가 저장됨
- 키 - 값 데이터 모델에서 확장된, 도큐먼트 기반 데이터베이스
- 확장성 뛰어남
- 빅데이터 저장에 성능 good
- 고가용성, 샤딩, 레플리카셋 지원
- 스키마 미지정하고 데이터 삽입가능
- 강점 : 데이터베이스 기반 분석 과 로깅 구현
- 유니크값인 ObjectID

### redis

- 인메모리 데이터베이스 , 키 - 값 데이터 모델 기반
- 기본 데이터 타입 : 문자열 , 최대 512MB 저장가능
- 셋(set) , 해시(Hash) 지원
- 사용처  : pub/sub 기능으로 채팅 시스템, 다른 데이터베이스 앞 단에 두어 사용하는 캐싱 계층,
    
    세션 정보 관리, 정렬된 셋(sorted set) 자료구조를 이용한 실시간 순위표 서비스
    

# 4.5 인덱스

## 인덱스의 필요성

인덱스 : 데이터를 빠르게 찾을 수 있는 하나의 장치

## B-트리

- 인덱스는 보통 B-트리라는 자료 구조로 이루어짐
- 루트 노드, 리프 노트, 브랜치 노드로 구성

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%2020.png)

E를 찾는다  → 전체 테이블 탐색X E가 있을 법한 리프 노드로 들어가 E탐색

→ 두번 만에 탐색 가능(D→E)

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%2021.png)

키 57을 찾는 경우  → 브랜치 노드를 거쳐 리프 노드까지 내려와 ‘ 57보다 같거나 클 때까지 ‘ 를 기반으로 정렬된 값 기반으로 탐색

**인덱스가 효율적인 이유와 대수 확장성**

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%2022.png)

트리 깊이 10개짜리는 100만개의 레코드 검색 가능

→ 실제 인덱스는 이것보다도 더 효율적이므로, 인덱스는 효율적이다.

## 인덱스 만드는 방법

### MySQL

- 클러스터형 인덱스, 세컨더리 인덱스
- 클러스터형 인덱스 :
    - 테이블당 하나를 설정
    - primary key옵션으로 기본키 만들 시 클러스터형 인덱스 생성
    - 기본키로 만들지 않고 unique not null 옵션을 붙여 클러스터형 인덱스로 만듦
- 세컨더리 인덱스 :
    - create index… 기반으로 만듦
    - 보조 인덱스로 여러 개 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야하는 인덱스

⇒ 하나의 인덱스만 생성할거면 클러스터형 인덱스를 만드는게 성능이 good

### MongoDB

- 도큐먼트를 만들면 자동으로 ObjectID 형성 및 기본키 설정
- 세컨더리 키도 부가 설정 하여, 기본키 + 세컨더리 키를 같이 사용하는 복합 인덱스 사용가능

## 인덱스 최적화 기법

1. ***인덱스는 비용이다***
    
    인덱스는 두 번 탐색을 강요함. {인덱스 리스트 → 컬렉션 순서} , 따라서 관련 읽기 비용이 듦
    
    컬렉션이 수정 시 , 인덱스 또한 수정 필요 ⇒ B-트리 높이 조절 비용 및 분산 비용 듦
    
    → 쿼리의 필드에 인덱스를 다 설정하면 , 컬렉션에서 가져와야하는 양이 많을 수록 인덱스 사용은 비효율적이다.
    
2. ***항상 테스팅 하라***
    
    인덱스 최적화 기법은 서비스 특징(객체의 깊이, 테이블의 양)에 따라 다르기에 테스팅이 중요하다
    
    쿼리를 보낸 후 테스팅을 하며 걸리는 시간을 최소화 해야 한다.
    
3. ***복합 인덱스는 같음,정렬, 다중 값, 카디널리티 순이다.***
    
    여러 필드을 조회 할 때, 복합 인덱스를 생성하는데, 이 때 순서가 있고, 생성 순서에 따라 인덱스 성능이 좌지우지됨
    
    **같음, 정렬, 다중 값 , 카디널리티** 순으로 생성해야 한다
    
    1. 어떠한 값과 같음을 비교하는 ==이나 equal이라는 쿼리가 있다면 제일 먼저 인덱스로 설정합니다.
    2. 정렬에 쓰는 필드라면 그다음 인덱스로 설정합니다.
    3. 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 >이거나 < 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스를 설정합니다.
    4. 유니크한 값의 정도를 카디널리티라고 합니다. 이 카디널리티가 높은 순서를 기반으로 인덱스를 생성해야 합니다. 예를 들어 age와 email이 있다고 해봅시다. 어떤 것이 더 높죠? 당연히 email입니다. 즉, email이라는 필드에 대한 인덱스를 먼저 생성해야하는 것입니다.

## 

# 4.6 조인의 종류

조인 : 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것

<조인 명령어>

MySQL : JOIN

MongoDB : lookup ← 근데 사용 지양 , mongodb는 조인 연산의 성능이 떨어짐

⇒ 조인 작업이 많을시 관계형 데이터 베이스를 사용해야함

![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%2023.png)

## 내부 조인

두 테이블 간의 교집합

```sql
SELECT * FROM TableA A
INNER JOIN TableB B ON
A.key = B.key
```

## 왼쪽 조인

테이블 B의 일치하는 부분의 레코드와 함께 테이블 A를 기준으로 완전한 레코드 집합 생성

테이블 B에 일치하는 항목이 없으면, 해당값은 null

```sql
SELECT * FROM TableA A
LEFT JOIN TableB B ON
A.key = B.key
```

## 오른쪽 조인

테이블 A에서 일치하는 부분의 레코드와 함께 테이블 日를 기준으로 완전한 레코 집합을 생성

테이블 A에 일치하는 항목이 없으면 해당 값은 null

```sql
SELECT * FROM TableA A
RIGHT JOIN TableB B ON
A.key = B.key
```

## 합집합 조인

양쪽 테이블에서 일치하는 레코드와 함께 테이블 A와 테이블 B의 모든 레코드 집합을 생성

일치하는 항목이 없으면 누락된 쪽에 null

```sql
SELECT * FROM TableA A
FULL OUTER JOIN TableB B ON
A.key = B.key
```

# 4.7 조인의 원리

조인은 조인의 원리를 기반으로 작업이 이루어짐

## 중첩루프 조인(NLJ)

- 중첩 for문과 같은 원리로 조건에 맞는 조인을 하는 방법
- 랜덤 접근에 대한 비용이 많이 증가 ← 대용량 테이블에서 지양
- 예를 들어 “tl, t2 테이블을 조인한다.”라고 했을 때 첫 번째 테이블에서 행을 한 번에 하나씩 읽고 그다음 테이블에서도 행을 하나씩 읽어 조건에 맞는 레코드를 찾아 결괏값을 반환

```purescript
for each row in t1 matching reference key {
	for each row in t2 matching reference key {
		if row satisfies join conditions, send to client
	}
}
```

## 정렬 병합 조인

- 각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행하는 조인
- 조인할 적절한 인덱스가 없고 , 대용량 테이블들을 조인하고, < > 등의 범위 비교연산자가 있을 시 사용

## 해시 조인

- 해시 테이블 기반으로 조인하는 방법
- 두 개의 테이블 조인 시, 하나의 테이블이 메모리에 온전히 들어간다면 보통 중첩 루프 조인보다 더 효율적
- **빌드 단계**
    
    ![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%2024.png)
    
    - 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계
    - 둘 중 바이트가 더 작은 테이블을 기반으로 테이블을 빌드
    - 조인에 사용되는 필드가 해시 테이블 키로 사용됨
- **프로브 단계**
- 
    
    ![Untitled](4%E1%84%8C%E1%85%A1%E1%86%BC(183p~229p)%20d26231f216c248e6bb5dae3be676aaaa/Untitled%2025.png)
    
    - 프로브 단계 동안 레코드 읽기 시작
    - 각 레코드에서 키 값에 일치하는 레코드를 찾아서 결과값으로 반환
    - 각 테이블을 한 번 만 읽게되어 중첩루프 조인보다 성능이 보통은 더 좋다
    - 사용 가능한 메모리 양은 시스템 변수 join_buffer_size에 의해 제어 → 런타임에 조정 가능